---
title: "Hankel-DMD: Time-Delay Embedding for Scalar Time Series"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Hankel-DMD: Time-Delay Embedding for Scalar Time Series}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

## Introduction

Standard DMD requires multivariate data (multiple state variables measured over time). But what if you only have a single scalar time series? **Hankel-DMD** solves this problem using time-delay embedding.

The key insight comes from Takens' embedding theorem: a scalar time series contains information about the full system dynamics when properly embedded in a higher-dimensional space using time delays.

## The Krylov Subspace Approach

Hankel-DMD constructs a Krylov subspace from the data, which has several advantages over standard DMD with arbitrary basis functions:

1. **Avoids the curse of dimensionality**: The basis is constructed from the data itself
2. **Captures dynamics naturally**: Time-shifted observations span the relevant subspace
3. **Works with scalar data**: No need for multiple measurement channels

This approach is based on Section 5 of Mezić (2020), "On Numerical Approximations of the Koopman Operator."

## Getting Started

```{r setup}
library(RKoopmanDMD)
```

### Example: Analyzing a Simple Oscillator

Let's start with a pure cosine wave:

```{r simple-oscillator}
# Generate scalar time series
dt <- 0.1
t <- seq(0, 20, by = dt)
y <- cos(2 * pi * 0.25 * t)  # 0.25 Hz oscillation

# Plot the signal
plot(t, y, type = "l", col = "steelblue", lwd = 2,
     xlab = "Time", ylab = "Signal",
     main = "Scalar Time Series")
```

### Fitting Hankel-DMD

```{r hankel-fit}
# Fit Hankel-DMD with 10 delays
model <- hankel_dmd(y, delays = 10, dt = dt)

print(model)
```

The output shows:
- Number of delays used for embedding
- Dimensions of the Hankel matrix
- Eigenvalues capturing the dynamics

### Understanding the Hankel Matrix

The Hankel matrix arranges time-shifted copies of the signal:

$$
H = \begin{bmatrix}
y_1 & y_2 & \cdots & y_{N-d} \\
y_2 & y_3 & \cdots & y_{N-d+1} \\
\vdots & \vdots & \ddots & \vdots \\
y_{d+1} & y_{d+2} & \cdots & y_N
\end{bmatrix}
$$

Each column is a delay-embedded snapshot of the system state.

```{r hankel-matrix}
# Examine the Hankel matrix dimensions
cat("Hankel matrix dimensions:", nrow(model$hankel), "x", ncol(model$hankel), "\n")
cat("Rows = delays + 1 =", model$delays + 1, "\n")
cat("Columns = time points - delays =", length(y) - model$delays, "\n")
```

## Detecting Oscillation Frequencies

The eigenvalues reveal the underlying frequencies:

```{r spectrum}
# Get frequency spectrum
spectrum <- dmd_spectrum(model, dt = dt)
print(spectrum[, c("mode", "magnitude", "frequency", "period")])
```

```{r spectrum-plot, fig.height=4}
# Visualize
par(mfrow = c(1, 2))

# Eigenvalues on unit circle
plot(model, which = 1)

# Frequency spectrum (using magnitude as proxy for importance)
barplot(spectrum$magnitude, names.arg = round(spectrum$frequency, 3),
        xlab = "Frequency (Hz)", ylab = "Magnitude",
        main = "Frequency Spectrum", col = "steelblue")
```

The dominant frequencies should include values near 0.25 Hz (the input frequency).

## Prediction with Hankel-DMD

### Forecasting Future Values

```{r prediction}
# Predict 50 steps ahead
n_ahead <- 50
pred <- predict(model, n_ahead = n_ahead)

# True future values for comparison
t_future <- max(t) + seq(dt, n_ahead * dt, by = dt)
y_true <- cos(2 * pi * 0.25 * t_future)

# Plot
par(mfrow = c(1, 1))
plot(t, y, type = "l", col = "steelblue", lwd = 2,
     xlim = c(0, max(t_future)), ylim = c(-1.2, 1.2),
     xlab = "Time", ylab = "Signal",
     main = "Hankel-DMD Prediction")
lines(t_future, pred[1,], col = "red", lwd = 2, lty = 2)
lines(t_future, y_true, col = "darkgreen", lwd = 1, lty = 3)
abline(v = max(t), col = "gray", lty = 3)
legend("topright", c("Training", "Prediction", "True Future"),
       col = c("steelblue", "red", "darkgreen"), lty = c(1, 2, 3), lwd = 2)
```

### Reconstruction

Check how well the model captures the training data:

```{r reconstruction}
recon <- hankel_reconstruct(model)

# Compare (note: reconstruction is shorter due to delay embedding)
t_recon <- t[(model$delays + 1):length(t)]

plot(t_recon, y[(model$delays + 1):length(y)], type = "l",
     col = "steelblue", lwd = 2,
     xlab = "Time", ylab = "Signal",
     main = "Reconstruction Quality")
lines(t_recon, recon[1,], col = "red", lwd = 2, lty = 2)
legend("topright", c("Original", "Reconstructed"),
       col = c("steelblue", "red"), lty = 1:2, lwd = 2)
```

## Multi-Frequency Signals

Hankel-DMD excels at decomposing signals with multiple frequencies:

```{r multi-frequency}
# Signal with two frequencies
y_multi <- cos(2 * pi * 0.1 * t) + 0.5 * sin(2 * pi * 0.3 * t)

plot(t, y_multi, type = "l", col = "steelblue", lwd = 2,
     xlab = "Time", ylab = "Signal",
     main = "Multi-Frequency Signal")
```

```{r multi-fit}
# Fit with more delays to capture both frequencies
model_multi <- hankel_dmd(y_multi, delays = 15, dt = dt)

# Check spectrum
spectrum_multi <- dmd_spectrum(model_multi, dt = dt)
print(spectrum_multi[1:6, c("mode", "frequency", "magnitude")])
```

The spectrum should show peaks near 0.1 Hz and 0.3 Hz.

## Choosing the Number of Delays

The number of delays is a key parameter:

- **Too few delays**: Cannot capture complex dynamics
- **Too many delays**: Overfitting and numerical issues

### Automatic Selection

If you don't specify `delays`, Hankel-DMD chooses automatically:

```{r auto-delays}
model_auto <- hankel_dmd(y)
cat("Automatically selected delays:", model_auto$delays, "\n")
```

### Guidelines for Manual Selection

1. **Oscillatory data**: At least 2-3 delays per period
2. **Multiple frequencies**: Enough delays to span the slowest period
3. **Noisy data**: Fewer delays to avoid fitting noise

```{r delay-comparison, fig.height=4}
# Compare different delay settings
par(mfrow = c(1, 3))

for (d in c(5, 15, 30)) {
  model_d <- hankel_dmd(y_multi, delays = d, dt = dt)
  spec_d <- dmd_spectrum(model_d, dt = dt)

  barplot(head(spec_d$magnitude, 8),
          names.arg = round(head(spec_d$frequency, 8), 2),
          main = paste("Delays =", d),
          xlab = "Frequency", ylab = "Amplitude",
          col = "steelblue", las = 2)
}
```

## Multivariate Data

Hankel-DMD also works with multivariate data, creating a block-Hankel matrix:

```{r multivariate}
# Two correlated time series
X <- rbind(
  cos(t),
  sin(t)
)

model_mv <- hankel_dmd(X, delays = 5)
print(model_mv)
```

The Hankel matrix now has `(delays + 1) * n_obs` rows:

```{r mv-dimensions}
cat("Number of observables:", model_mv$n_obs, "\n")
cat("Hankel rows:", nrow(model_mv$hankel), "\n")
cat("Expected: (delays + 1) * n_obs =", (model_mv$delays + 1) * model_mv$n_obs, "\n")
```

## Stability Analysis

Check if the identified dynamics are stable:

```{r stability}
stability <- dmd_stability(model)
print(stability)
```

For a pure oscillator, eigenvalues should be on the unit circle (marginally stable).

## Noisy Data

Hankel-DMD can handle moderate noise:

```{r noisy}
set.seed(42)
y_noisy <- y + 0.2 * rnorm(length(y))

model_noisy <- hankel_dmd(y_noisy, delays = 10, dt = dt)

# Compare spectra
spectrum_noisy <- dmd_spectrum(model_noisy, dt = dt)
cat("Detected frequency:", spectrum_noisy$frequency[1], "Hz\n")
cat("True frequency: 0.25 Hz\n")
```

```{r noisy-plot}
# Prediction still works reasonably
pred_noisy <- predict(model_noisy, n_ahead = 30)
t_pred <- max(t) + seq(dt, 30 * dt, by = dt)

plot(t, y_noisy, type = "l", col = "gray", lwd = 1,
     xlim = c(0, max(t_pred)),
     xlab = "Time", ylab = "Signal",
     main = "Noisy Signal Prediction")
lines(t, y, col = "steelblue", lwd = 2)
lines(t_pred, pred_noisy[1,], col = "red", lwd = 2, lty = 2)
legend("topright", c("Noisy Data", "True Signal", "Prediction"),
       col = c("gray", "steelblue", "red"), lty = c(1, 1, 2), lwd = c(1, 2, 2))
```

## Connection to Standard DMD

Hankel-DMD is compatible with all standard DMD analysis functions:

```{r compatibility}
# These all work with hankel_dmd objects
spectrum <- dmd_spectrum(model)
stability <- dmd_stability(model)
dominant <- dmd_dominant_modes(model, n = 3)

cat("Number of dominant modes:", nrow(dominant), "\n")
```

## Summary

Hankel-DMD extends DMD to scalar time series through time-delay embedding:

| Feature | Standard DMD | Hankel-DMD |
|---------|--------------|------------|
| Input | Multivariate | Scalar or multivariate |
| Basis | User-specified or full state | Data-driven (Krylov) |
| Dimensionality | Can be high | Controlled by delays |
| Frequency detection | Good | Excellent for periodic signals |

## References

1. Mezić, I. (2020). On Numerical Approximations of the Koopman Operator. arXiv:2009.05883.

2. Takens, F. (1981). Detecting strange attractors in turbulence. In *Dynamical Systems and Turbulence*, Springer.

3. Arbabi, H., & Mezić, I. (2017). Ergodic theory, dynamic mode decomposition, and computation of spectral properties of the Koopman operator. *SIAM Journal on Applied Dynamical Systems*, 16(4), 2096-2126.
