% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dmd.R
\name{dmd}
\alias{dmd}
\title{Dynamic Mode Decomposition}
\usage{
dmd(X, rank = NULL, center = FALSE, lifting = NULL, observables = NULL)
}
\arguments{
\item{X}{A numeric matrix where rows represent state variables and columns
represent time snapshots. Must have at least 2 rows and 3 columns.}

\item{rank}{Integer specifying the rank for SVD truncation. If \code{NULL}
(default), rank is automatically selected to capture 99\% of variance.}

\item{center}{Logical; if \code{TRUE}, the data is centered by subtracting the
row means before analysis. Default is \code{FALSE}.}

\item{lifting}{Lifting function specification for extended DMD. Can be:
\describe{
\item{NULL}{(default) No lifting, standard DMD}
\item{character}{Built-in lifting: \code{"poly2"}, \code{"poly3"}, \code{"poly4"},
\code{"poly_cross2"}, \code{"poly_cross3"}, \code{"trig"}, \code{"trig2"},
\code{"delay2"}, \code{"delay3"}, \code{"delay5"}}
\item{function}{Custom lifting function taking matrix X and returning
lifted matrix with same number of columns}
\item{list}{Parametric specification, e.g.,
\code{list(type = "poly", degree = 4)} or
\code{list(type = "rbf", centers = centers_matrix, sigma = 0.5)}}
}
See \code{\link[=list_lifting_functions]{list_lifting_functions()}} for available options.}

\item{observables}{Integer vector specifying which rows of the lifted state
correspond to the original observable states. Default is \code{1:nrow(X)},
assuming the first n rows are the original states. Used for projecting
predictions back to observable space.}
}
\value{
An object of class \code{"dmd"} containing:
\describe{
\item{A}{The DMD matrix (Koopman operator approximation) in the original
state space. Multiplying a state by A gives the predicted next state.}
\item{modes}{Complex matrix of DMD modes (columns). Each mode represents
a spatial pattern that evolves with a single frequency and growth rate.}
\item{eigenvalues}{Complex vector of DMD eigenvalues. The magnitude
indicates growth/decay rate; the angle indicates oscillation frequency.}
\item{amplitudes}{Complex vector of initial mode amplitudes, computed
by projecting the first snapshot onto the modes.}
\item{rank}{Integer; the rank used for truncation.}
\item{svd}{List containing truncated SVD components (U, S, V).}
\item{A_tilde}{The reduced DMD matrix in the SVD coordinate system.}
\item{X_first}{First column of input data (initial condition).}
\item{X_last}{Last column of input data (for prediction initialization).}
\item{data_dim}{Dimensions of the input matrix (rows, columns).}
\item{center}{Logical; whether centering was applied.}
\item{X_mean}{Row means if centering was applied, otherwise NULL.}
\item{dt}{Time step (currently set to 1; for future extension).}
\item{call}{The matched function call.}
\item{lifting}{The lifting specification used (NULL if none).}
\item{lifting_fn}{The actual lifting function (NULL if none).}
\item{observables}{Indices of observable states in lifted space.}
\item{n_vars_original}{Number of original state variables.}
\item{n_vars_lifted}{Number of lifted state variables.}
}
}
\description{
Performs Dynamic Mode Decomposition (DMD) on time-series data to extract
spatiotemporal modes, eigenvalues, and a linear operator approximating
the system dynamics.
}
\details{
DMD approximates the dynamics of a system by finding the best-fit linear
operator \eqn{A} such that \eqn{X_2 \approx A X_1}, where \eqn{X_1} and
\eqn{X_2} are time-shifted versions of the data.

The algorithm:
\enumerate{
\item Splits data into \eqn{X_1 = X[, 1:(n-1)]} and \eqn{X_2 = X[, 2:n]}
\item Computes truncated SVD of \eqn{X_1}: \eqn{X_1 = U \Sigma V^T}
\item Projects onto reduced coordinates: \eqn{\tilde{A} = U^T X_2 V \Sigma^{-1}}
\item Computes eigendecomposition of \eqn{\tilde{A}}
\item Recovers full-space modes: \eqn{\Phi = X_2 V \Sigma^{-1} W}
}
}
\section{Interpreting Results}{

\itemize{
\item \strong{Eigenvalue magnitude < 1}: Mode is decaying (stable)
\item \strong{Eigenvalue magnitude = 1}: Mode is neutral (marginally stable)
\item \strong{Eigenvalue magnitude > 1}: Mode is growing (unstable)
\item \strong{Eigenvalue phase}: Determines oscillation frequency as \eqn{\omega = \arg(\lambda) / \Delta t}
}
}

\examples{
# Create a simple oscillatory system
t <- seq(0, 10, by = 0.1)
x1 <- cos(2 * pi * 0.5 * t)
x2 <- sin(2 * pi * 0.5 * t)
X <- rbind(x1, x2)

# Fit DMD model
model <- dmd(X)

# Examine the model
print(model)
summary(model)

# Check eigenvalue magnitudes (should be ~1 for oscillatory system)
Mod(model$eigenvalues)

# Example with lifting for nonlinear dynamics
t <- seq(0, 10, by = 0.1)
x1 <- cos(t) + 0.3 * cos(t)^2  # Nonlinear component
x2 <- sin(t)
X_nonlin <- rbind(x1, x2)

# Standard DMD
model_std <- dmd(X_nonlin)

# DMD with polynomial lifting
model_lift <- dmd(X_nonlin, lifting = "poly2")

# Check lifted dimensions
model_lift$n_vars_original  # 2
model_lift$n_vars_lifted    # 4 (x1, x2, x1^2, x2^2)

}
\references{
Schmid, P. J. (2010). Dynamic mode decomposition of numerical and
experimental data. Journal of Fluid Mechanics, 656, 5-28.
}
\seealso{
\code{\link[=predict.dmd]{predict.dmd()}} for forecasting, \code{\link[=dmd_spectrum]{dmd_spectrum()}} for eigenvalue
analysis, \code{\link[=dmd_reconstruct]{dmd_reconstruct()}} for data reconstruction,
\code{\link[=dmd_lift]{dmd_lift()}} for inspecting lifting transformations,
\code{\link[=list_lifting_functions]{list_lifting_functions()}} for available lifting options.
}
