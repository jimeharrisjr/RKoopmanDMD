% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.R
\name{predict.dmd}
\alias{predict.dmd}
\title{Predict Future States Using DMD}
\usage{
\method{predict}{dmd}(
  object,
  n_ahead = 10,
  x0 = NULL,
  method = c("modes", "matrix"),
  return_lifted = FALSE,
  ...
)
}
\arguments{
\item{object}{A \code{"dmd"} object created by \code{\link[=dmd]{dmd()}}.}

\item{n_ahead}{Integer; number of time steps to forecast. Default is 10.}

\item{x0}{Numeric vector; initial state for prediction. If \code{NULL} (default),
uses the last observed state from the training data. For models with
lifting, provide the state in the original (unlifted) space; it will
be automatically lifted.}

\item{method}{Character; prediction method to use:
\describe{
\item{"modes"}{(Default) Uses eigenvalue evolution of modes. More
accurate for long-term predictions and provides insight into
modal contributions.}
\item{"matrix"}{Direct iterated matrix multiplication. Faster but
may accumulate numerical errors over many steps.}
}}

\item{return_lifted}{Logical; if \code{TRUE} and the model uses lifting,
return predictions in the full lifted space. If \code{FALSE} (default),
predictions are projected back to the original observable space.}

\item{...}{Additional arguments (currently unused, for S3 compatibility).}
}
\value{
A numeric matrix with dimensions (n_vars x n_ahead), where each
column represents the predicted state at successive future time steps.
If a lifting function was used and \code{return_lifted = FALSE}, the output
has dimensions (n_vars_original x n_ahead) in the original observable space.
}
\description{
Forecasts future states of a dynamical system using a fitted DMD model.
Supports two prediction methods: direct matrix multiplication or mode-based
eigenvalue evolution.
}
\details{
\subsection{Mode-based Prediction (method = "modes")}{

Each DMD mode evolves independently according to its eigenvalue:
\deqn{x(t) = \sum_i b_i \lambda_i^t \phi_i}
where \eqn{b_i} are the mode amplitudes, \eqn{\lambda_i} are eigenvalues,
and \eqn{\phi_i} are the modes.
}

\subsection{Matrix-based Prediction (method = "matrix")}{

Iteratively applies the DMD matrix:
\deqn{x(t+1) = A x(t)}

The mode-based method is generally preferred because it:
\itemize{
\item Provides insight into which modes dominate at different times
\item Is more numerically stable for long predictions
\item Allows analytical computation without iteration
}
}
}
\examples{
# Create oscillatory data
t <- seq(0, 10, by = 0.1)
X <- rbind(cos(t), sin(t))

# Fit DMD model
model <- dmd(X)

# Predict next 50 time steps from last observed state
future <- predict(model, n_ahead = 50)

# Predict from a custom initial condition
custom_start <- c(0.5, 0.5)
future_custom <- predict(model, n_ahead = 50, x0 = custom_start)

# Compare prediction methods
pred_modes <- predict(model, n_ahead = 20, method = "modes")
pred_matrix <- predict(model, n_ahead = 20, method = "matrix")

}
\seealso{
\code{\link[=dmd]{dmd()}} for fitting the model, \code{\link[=dmd_reconstruct]{dmd_reconstruct()}} for
reconstructing training data, \code{\link[=dmd_lift]{dmd_lift()}} for examining lifting.
}
